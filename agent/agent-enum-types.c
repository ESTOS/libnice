
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */

#include <config.h>
#include <glib-object.h>
#include "agent.h"
#include "pseudotcp.h"
#include "agent-enum-types.h"

/* enumerations from "./agent.h" */
GType
nice_component_state_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_COMPONENT_STATE_DISCONNECTED, "NICE_COMPONENT_STATE_DISCONNECTED", "disconnected" },
      { NICE_COMPONENT_STATE_GATHERING, "NICE_COMPONENT_STATE_GATHERING", "gathering" },
      { NICE_COMPONENT_STATE_CONNECTING, "NICE_COMPONENT_STATE_CONNECTING", "connecting" },
      { NICE_COMPONENT_STATE_CONNECTED, "NICE_COMPONENT_STATE_CONNECTED", "connected" },
      { NICE_COMPONENT_STATE_READY, "NICE_COMPONENT_STATE_READY", "ready" },
      { NICE_COMPONENT_STATE_FAILED, "NICE_COMPONENT_STATE_FAILED", "failed" },
      { NICE_COMPONENT_STATE_LAST, "NICE_COMPONENT_STATE_LAST", "last" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceComponentState", values);
  }
  return type;
}
GType
nice_component_type_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_COMPONENT_TYPE_RTP, "NICE_COMPONENT_TYPE_RTP", "rtp" },
      { NICE_COMPONENT_TYPE_RTCP, "NICE_COMPONENT_TYPE_RTCP", "rtcp" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceComponentType", values);
  }
  return type;
}
GType
nice_compatibility_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_COMPATIBILITY_RFC5245, "NICE_COMPATIBILITY_RFC5245", "rfc5245" },
      { NICE_COMPATIBILITY_DRAFT19, "NICE_COMPATIBILITY_DRAFT19", "draft19" },
      { NICE_COMPATIBILITY_GOOGLE, "NICE_COMPATIBILITY_GOOGLE", "google" },
      { NICE_COMPATIBILITY_MSN, "NICE_COMPATIBILITY_MSN", "msn" },
      { NICE_COMPATIBILITY_WLM2009, "NICE_COMPATIBILITY_WLM2009", "wlm2009" },
      { NICE_COMPATIBILITY_OC2007, "NICE_COMPATIBILITY_OC2007", "oc2007" },
      { NICE_COMPATIBILITY_OC2007R2, "NICE_COMPATIBILITY_OC2007R2", "oc2007r2" },
      { NICE_COMPATIBILITY_LAST, "NICE_COMPATIBILITY_LAST", "last" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceCompatibility", values);
  }
  return type;
}
GType
nice_proxy_type_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_PROXY_TYPE_NONE, "NICE_PROXY_TYPE_NONE", "none" },
      { NICE_PROXY_TYPE_SOCKS5, "NICE_PROXY_TYPE_SOCKS5", "socks5" },
      { NICE_PROXY_TYPE_HTTP, "NICE_PROXY_TYPE_HTTP", "http" },
      { NICE_PROXY_TYPE_LAST, "NICE_PROXY_TYPE_LAST", "last" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceProxyType", values);
  }
  return type;
}
GType
nice_nomination_mode_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_NOMINATION_MODE_REGULAR, "NICE_NOMINATION_MODE_REGULAR", "regular" },
      { NICE_NOMINATION_MODE_AGGRESSIVE, "NICE_NOMINATION_MODE_AGGRESSIVE", "aggressive" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceNominationMode", values);
  }
  return type;
}
GType
nice_agent_option_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GFlagsValue values[] = {
      { NICE_AGENT_OPTION_REGULAR_NOMINATION, "NICE_AGENT_OPTION_REGULAR_NOMINATION", "regular-nomination" },
      { NICE_AGENT_OPTION_RELIABLE, "NICE_AGENT_OPTION_RELIABLE", "reliable" },
      { NICE_AGENT_OPTION_LITE_MODE, "NICE_AGENT_OPTION_LITE_MODE", "lite-mode" },
      { NICE_AGENT_OPTION_ICE_TRICKLE, "NICE_AGENT_OPTION_ICE_TRICKLE", "ice-trickle" },
      { NICE_AGENT_OPTION_SUPPORT_RENOMINATION, "NICE_AGENT_OPTION_SUPPORT_RENOMINATION", "support-renomination" },
      { 0, NULL, NULL }
    };
    type = g_flags_register_static ("NiceAgentOption", values);
  }
  return type;
}

/* enumerations from "./candidate.h" */
GType
nice_candidate_type_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_CANDIDATE_TYPE_HOST, "NICE_CANDIDATE_TYPE_HOST", "host" },
      { NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE, "NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE", "server-reflexive" },
      { NICE_CANDIDATE_TYPE_PEER_REFLEXIVE, "NICE_CANDIDATE_TYPE_PEER_REFLEXIVE", "peer-reflexive" },
      { NICE_CANDIDATE_TYPE_RELAYED, "NICE_CANDIDATE_TYPE_RELAYED", "relayed" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceCandidateType", values);
  }
  return type;
}
GType
nice_candidate_transport_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_CANDIDATE_TRANSPORT_UDP, "NICE_CANDIDATE_TRANSPORT_UDP", "udp" },
      { NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE, "NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE", "tcp-active" },
      { NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE, "NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE", "tcp-passive" },
      { NICE_CANDIDATE_TRANSPORT_TCP_SO, "NICE_CANDIDATE_TRANSPORT_TCP_SO", "tcp-so" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceCandidateTransport", values);
  }
  return type;
}
GType
nice_relay_type_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { NICE_RELAY_TYPE_TURN_UDP, "NICE_RELAY_TYPE_TURN_UDP", "udp" },
      { NICE_RELAY_TYPE_TURN_TCP, "NICE_RELAY_TYPE_TURN_TCP", "tcp" },
      { NICE_RELAY_TYPE_TURN_TLS, "NICE_RELAY_TYPE_TURN_TLS", "tls" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("NiceRelayType", values);
  }
  return type;
}

/* enumerations from "./pseudotcp.h" */
GType
pseudo_tcp_debug_level_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { PSEUDO_TCP_DEBUG_NONE, "PSEUDO_TCP_DEBUG_NONE", "none" },
      { PSEUDO_TCP_DEBUG_NORMAL, "PSEUDO_TCP_DEBUG_NORMAL", "normal" },
      { PSEUDO_TCP_DEBUG_VERBOSE, "PSEUDO_TCP_DEBUG_VERBOSE", "verbose" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("PseudoTcpDebugLevel", values);
  }
  return type;
}
GType
pseudo_tcp_state_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { PSEUDO_TCP_LISTEN, "PSEUDO_TCP_LISTEN", "listen" },
      { PSEUDO_TCP_SYN_SENT, "PSEUDO_TCP_SYN_SENT", "syn-sent" },
      { PSEUDO_TCP_SYN_RECEIVED, "PSEUDO_TCP_SYN_RECEIVED", "syn-received" },
      { PSEUDO_TCP_ESTABLISHED, "PSEUDO_TCP_ESTABLISHED", "established" },
      { PSEUDO_TCP_CLOSED, "PSEUDO_TCP_CLOSED", "closed" },
      { PSEUDO_TCP_FIN_WAIT_1, "PSEUDO_TCP_FIN_WAIT_1", "fin-wait-1" },
      { PSEUDO_TCP_FIN_WAIT_2, "PSEUDO_TCP_FIN_WAIT_2", "fin-wait-2" },
      { PSEUDO_TCP_CLOSING, "PSEUDO_TCP_CLOSING", "closing" },
      { PSEUDO_TCP_TIME_WAIT, "PSEUDO_TCP_TIME_WAIT", "time-wait" },
      { PSEUDO_TCP_CLOSE_WAIT, "PSEUDO_TCP_CLOSE_WAIT", "close-wait" },
      { PSEUDO_TCP_LAST_ACK, "PSEUDO_TCP_LAST_ACK", "last-ack" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("PseudoTcpState", values);
  }
  return type;
}
GType
pseudo_tcp_write_result_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { WR_SUCCESS, "WR_SUCCESS", "success" },
      { WR_TOO_LARGE, "WR_TOO_LARGE", "too-large" },
      { WR_FAIL, "WR_FAIL", "fail" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("PseudoTcpWriteResult", values);
  }
  return type;
}
GType
pseudo_tcp_shutdown_get_type (void)
{
  static GType type = 0;
  if (!type) {
    static const GEnumValue values[] = {
      { PSEUDO_TCP_SHUTDOWN_RD, "PSEUDO_TCP_SHUTDOWN_RD", "rd" },
      { PSEUDO_TCP_SHUTDOWN_WR, "PSEUDO_TCP_SHUTDOWN_WR", "wr" },
      { PSEUDO_TCP_SHUTDOWN_RDWR, "PSEUDO_TCP_SHUTDOWN_RDWR", "rdwr" },
      { 0, NULL, NULL }
    };
    type = g_enum_register_static ("PseudoTcpShutdown", values);
  }
  return type;
}

/* Generated data ends here */

